---
- name: "MLOps CI/CD Stages on Remote Host"
  hosts: server
  gather_facts: no 
  vars:
    # Variables passed from the Jenkinsfile environment
    backend_image: "{{ lookup('env', 'BACKEND_IMAGE') }}"
    frontend_image: "{{ lookup('env', 'FRONTEND_IMAGE') }}"
    docker_tag: "{{ lookup('env', 'DOCKER_TAG') }}"
    dockerhub_user: "{{ lookup('env', 'DOCKER_USR') }}"
    dockerhub_pass: "{{ lookup('env', 'DOCKER_PSW') }}"
    kubeconfig_path: "{{ ansible_user_dir }}/.kube/config"
  
  vars_files:
    - sudo_pwd_vault.yml

  tasks:
    - name: Ensure project directory exists
      ansible.builtin.file:
        path: /home/{{ ansible_user }}/project_workspace
        state: directory
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}" # Explicitly set group for clarity
        mode: '0755'
      become: yes

    - name: Ensure MLflow history directory exists and is owned by user
      ansible.builtin.file:
        path: /home/{{ ansible_user }}/mlflow_history
        state: directory
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0755'
      become: yes
      
    - name: Copy MLflow history to remote host
      ansible.builtin.synchronize:
        src: "/var/lib/jenkins/mlflow_history/"
        dest: "/home/{{ ansible_user }}/mlflow_history/"
        mode: push
        archive: yes
      become: yes

    - name: Copy Code, Config, and DVC Pointers
      ansible.builtin.synchronize:
        src: "{{ workspace }}/"
        dest: /home/{{ ansible_user }}/project_workspace/
        mode: push
        archive: yes
      args:
        rsync_opts:
          - "--exclude=.dvc/cache" 
      become: yes

    - name: Get Minikube IP
      ansible.builtin.command: minikube ip
      register: minikube_ip_cmd

    - name: Add Minikube hostnames to /etc/hosts
      become: yes
      ansible.builtin.lineinfile:
        path: /etc/hosts
        line: "{{ minikube_ip_cmd.stdout }} rottenpotatoes.com kibana.com"
        state: present

    - name: 1. TRAIN MODEL (CI)
      ansible.builtin.shell: |
        echo "Starting MLOps training steps..."
        set -e
        cd /home/{{ ansible_user }}/project_workspace
        
        # Setup Venv
        python3 -m venv venv
        . venv/bin/activate
        pip install --upgrade pip
        pip install -r requirements.txt

        # DVC: Uses the shared, permanent archive
        dvc remote remove mylocal || true # Clean up old reference
        dvc remote add -d -f mylocal /tmp/dvc_store
        dvc pull
        
        # Handle MLflow history link (Ensure path is consistent)
        ln -sf /home/{{ ansible_user }}/mlflow_history mlruns
        python3 train.py
      args:
        chdir: /home/{{ ansible_user }}/project_workspace
      become: yes

    - name: 2. BUILD DOCKER IMAGES
      ansible.builtin.shell: |
        set -e
        cd /home/{{ ansible_user }}/project_workspace
        docker build -f Dockerfile.backend -t {{ backend_image }}:{{ docker_tag }} .
        docker build -f Dockerfile.frontend -t {{ frontend_image }}:{{ docker_tag }} .
      args:
        chdir: /home/{{ ansible_user }}/project_workspace
      become: yes

    - name: 3. PUSH TO DOCKER HUB
      ansible.builtin.shell: |
        set -e
        cd /home/{{ ansible_user }}/project_workspace
        echo "{{ dockerhub_pass }}" | docker login -u "{{ dockerhub_user }}" --password-stdin
        docker push {{ backend_image }}:{{ docker_tag }}
        docker push {{ frontend_image }}:{{ docker_tag }}
        docker logout
      become: yes

    - name: 4. UPDATE KUBERNETES DEPLOYMENT
      ansible.builtin.shell: |
        set -e
        cd /home/{{ ansible_user }}/project_workspace

        kubectl --kubeconfig={{ kubeconfig_path }} apply -f k8s-logging.yaml
        kubectl --kubeconfig={{ kubeconfig_path }} apply -f k8s-database.yaml

        kubectl --kubeconfig={{ kubeconfig_path }} apply -f k8s-backend.yaml
        kubectl --kubeconfig={{ kubeconfig_path }} apply -f k8s-frontend.yaml

        kubectl --kubeconfig={{ kubeconfig_path }} apply -f k8s-ingress.yaml

        kubectl --kubeconfig={{ kubeconfig_path }} rollout restart deployment/backend-deployment
        kubectl --kubeconfig={{ kubeconfig_path }} rollout restart deployment/frontend-deployment
      become: yes

    - name: 5. DEPLOY LOGGING INFRASTRUCTURE
      ansible.builtin.shell: |
        kubectl --kubeconfig={{ kubeconfig_path }} rollout status deployment/kibana --timeout=300s
      args:
        chdir: /home/{{ ansible_user }}/project_workspace
      become: yes

    - name: 6. CONFIGURE KIBANA 
      ansible.builtin.uri:
        url: "http://kibana.com/api/saved_objects/index-pattern/rotten_potatoes_pattern"
        method: POST
        headers:
          kbn-xsrf: "true" # Required by Kibana to prove this isn't a hacker attack
          Content-Type: "application/json"
        body_format: json
        body:
          attributes:
            title: "rotten_potatoes_logs*"
            timeFieldName: "timestamp"
        status_code: [200, 409] 
      register: kibana_response
      retries: 10     
      delay: 10        
      until: kibana_response.status == 200 or kibana_response.status == 409

      